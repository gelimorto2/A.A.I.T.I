const express = require('express');
const fs = require('fs');
const path = require('path');
const { authenticateToken, authenticateApiKey, requirePermissions, auditLog, logSecurityEvent } = require('../middleware/auth');
const { db } = require('../database/init');
const logger = require('../utils/logger');

const router = express.Router();

/**
 * Generate comprehensive audit report
 * GET /api/compliance/audit-report
 */
router.get('/audit-report', 
  authenticateApiKey,
  requirePermissions(['admin', 'read']),
  auditLog('compliance_audit_report_generated'),
  async (req, res) => {
    try {
      const { startDate, endDate, userId, action, format = 'json' } = req.query;

      // Build query conditions
      let whereConditions = [];
      let queryParams = [];

      if (startDate) {
        whereConditions.push('timestamp >= ?');
        queryParams.push(startDate);
      }

      if (endDate) {
        whereConditions.push('timestamp <= ?');
        queryParams.push(endDate);
      }

      if (userId) {
        whereConditions.push('user_id = ?');
        queryParams.push(userId);
      }

      if (action) {
        whereConditions.push('action LIKE ?');
        queryParams.push(`%${action}%`);
      }

      const whereClause = whereConditions.length > 0 ? 
        `WHERE ${whereConditions.join(' AND ')}` : '';

      // Get audit logs
      const auditLogs = await new Promise((resolve, reject) => {
        const query = `
          SELECT 
            al.*,
            u.username,
            u.email,
            u.role
          FROM audit_logs al
          LEFT JOIN users u ON al.user_id = u.id
          ${whereClause}
          ORDER BY al.timestamp DESC
          LIMIT 10000
        `;

        db.all(query, queryParams, (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });

      // Get security events
      const securityEvents = await new Promise((resolve, reject) => {
        const query = `
          SELECT 
            se.*,
            u.username,
            u.email,
            u.role
          FROM security_events se
          LEFT JOIN users u ON se.user_id = u.id
          ${whereClause.replace('timestamp', 'se.timestamp')}
          ORDER BY se.timestamp DESC
          LIMIT 5000
        `;

        db.all(query, queryParams, (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });

      // Generate summary statistics
      const summary = {
        totalAuditLogs: auditLogs.length,
        totalSecurityEvents: securityEvents.length,
        dateRange: {
          start: startDate || 'All time',
          end: endDate || 'Present'
        },
        userActions: {},
        actionTypes: {},
        securityEventTypes: {},
        riskEvents: securityEvents.filter(event => 
          event.event_severity === 'warning' || event.event_severity === 'critical'
        ).length
      };

      // Analyze audit logs
      auditLogs.forEach(log => {
        const username = log.username || 'System';
        summary.userActions[username] = (summary.userActions[username] || 0) + 1;
        summary.actionTypes[log.action] = (summary.actionTypes[log.action] || 0) + 1;
      });

      // Analyze security events
      securityEvents.forEach(event => {
        summary.securityEventTypes[event.event_type] = 
          (summary.securityEventTypes[event.event_type] || 0) + 1;
      });

      const reportData = {
        summary,
        auditLogs: auditLogs.slice(0, 1000), // Limit for response size
        securityEvents: securityEvents.slice(0, 500),
        generatedAt: new Date().toISOString(),
        generatedBy: req.user.username
      };

      // Handle different formats
      if (format === 'csv') {
        const csv = generateCSVReport(reportData);
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="audit-report.csv"');
        res.send(csv);
      } else if (format === 'json') {
        res.json({
          message: 'Audit report generated successfully',
          report: reportData
        });
      } else {
        res.status(400).json({ error: 'Unsupported format. Use json or csv.' });
      }

      logger.info(`Audit report generated by ${req.user.username} for period ${startDate || 'start'} to ${endDate || 'end'}`);
    } catch (error) {
      logger.error('Error generating audit report:', error);
      res.status(500).json({ error: 'Failed to generate audit report' });
    }
  }
);

/**
 * Generate trading activity report
 * GET /api/compliance/trading-report
 */
router.get('/trading-report',
  authenticateApiKey,
  requirePermissions(['admin', 'trading', 'read']),
  auditLog('compliance_trading_report_generated'),
  async (req, res) => {
    try {
      const { startDate, endDate, userId, symbol, format = 'json' } = req.query;

      // Build query conditions
      let whereConditions = [];
      let queryParams = [];

      if (startDate) {
        whereConditions.push('ts.timestamp >= ?');
        queryParams.push(startDate);
      }

      if (endDate) {
        whereConditions.push('ts.timestamp <= ?');
        queryParams.push(endDate);
      }

      if (userId) {
        whereConditions.push('b.user_id = ?');
        queryParams.push(userId);
      }

      if (symbol) {
        whereConditions.push('ts.symbol = ?');
        queryParams.push(symbol);
      }

      const whereClause = whereConditions.length > 0 ? 
        `WHERE ${whereConditions.join(' AND ')}` : '';

      // Get trading signals and related data
      const tradingData = await new Promise((resolve, reject) => {
        const query = `
          SELECT 
            ts.*,
            b.name as bot_name,
            b.trading_mode,
            b.strategy_type,
            u.username,
            u.email
          FROM trading_signals ts
          JOIN bots b ON ts.bot_id = b.id
          JOIN users u ON b.user_id = u.id
          ${whereClause}
          ORDER BY ts.timestamp DESC
          LIMIT 10000
        `;

        db.all(query, queryParams, (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });

      // Get bot performance metrics
      const performanceData = await new Promise((resolve, reject) => {
        const query = `
          SELECT 
            bm.*,
            b.name as bot_name,
            u.username
          FROM bot_metrics bm
          JOIN bots b ON bm.bot_id = b.id
          JOIN users u ON b.user_id = u.id
          ${whereClause.replace('ts.', 'bm.')}
          ORDER BY bm.timestamp DESC
          LIMIT 5000
        `;

        db.all(query, queryParams, (err, rows) => {
          if (err) reject(err);
          else resolve(rows);
        });
      });

      // Generate trading summary
      const summary = {
        totalSignals: tradingData.length,
        totalPerformanceRecords: performanceData.length,
        uniqueSymbols: [...new Set(tradingData.map(t => t.symbol))],
        uniqueUsers: [...new Set(tradingData.map(t => t.username))],
        signalTypes: {},
        tradingModes: {},
        dateRange: {
          start: startDate || 'All time',
          end: endDate || 'Present'
        }
      };

      // Analyze trading data
      tradingData.forEach(trade => {
        summary.signalTypes[trade.signal_type] = 
          (summary.signalTypes[trade.signal_type] || 0) + 1;
        summary.tradingModes[trade.trading_mode] = 
          (summary.tradingModes[trade.trading_mode] || 0) + 1;
      });

      const reportData = {
        summary,
        tradingSignals: tradingData.slice(0, 1000),
        performanceMetrics: performanceData.slice(0, 500),
        generatedAt: new Date().toISOString(),
        generatedBy: req.user.username
      };

      // Handle different formats
      if (format === 'csv') {
        const csv = generateTradingCSV(reportData);
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="trading-report.csv"');
        res.send(csv);
      } else if (format === 'json') {
        res.json({
          message: 'Trading report generated successfully',
          report: reportData
        });
      } else {
        res.status(400).json({ error: 'Unsupported format. Use json or csv.' });
      }

      logger.info(`Trading report generated by ${req.user.username}`);
    } catch (error) {
      logger.error('Error generating trading report:', error);
      res.status(500).json({ error: 'Failed to generate trading report' });
    }
  }
);

/**
 * Get compliance status and metrics
 * GET /api/compliance/status
 */
router.get('/status',
  authenticateApiKey,
  requirePermissions(['admin', 'read']),
  async (req, res) => {
    try {
      const now = new Date();
      const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

      // Get recent audit activity
      const recentAudits = await new Promise((resolve, reject) => {
        db.get(
          'SELECT COUNT(*) as count FROM audit_logs WHERE timestamp >= ?',
          [thirtyDaysAgo.toISOString()],
          (err, row) => {
            if (err) reject(err);
            else resolve(row.count);
          }
        );
      });

      // Get security events by severity
      const securityEventsByType = await new Promise((resolve, reject) => {
        db.all(
          `SELECT event_severity, COUNT(*) as count 
           FROM security_events 
           WHERE timestamp >= ? 
           GROUP BY event_severity`,
          [thirtyDaysAgo.toISOString()],
          (err, rows) => {
            if (err) reject(err);
            else resolve(rows);
          }
        );
      });

      // Get active API keys
      const activeApiKeys = await new Promise((resolve, reject) => {
        db.get(
          'SELECT COUNT(*) as count FROM api_keys WHERE is_active = 1',
          (err, row) => {
            if (err) reject(err);
            else resolve(row.count);
          }
        );
      });

      // Get data retention status
      const dataRetentionPolicies = await new Promise((resolve, reject) => {
        db.all(
          'SELECT * FROM data_retention_policies WHERE is_active = 1',
          (err, rows) => {
            if (err) reject(err);
            else resolve(rows);
          }
        );
      });

      const complianceStatus = {
        auditingStatus: {
          recentAuditLogs: recentAudits,
          status: recentAudits > 0 ? 'Active' : 'Inactive'
        },
        securityStatus: {
          eventsByType: securityEventsByType.reduce((acc, event) => {
            acc[event.event_severity] = event.count;
            return acc;
          }, {}),
          activeApiKeys: activeApiKeys
        },
        dataRetention: {
          activePolicies: dataRetentionPolicies.length,
          policies: dataRetentionPolicies
        },
        complianceScore: calculateComplianceScore(recentAudits, securityEventsByType, dataRetentionPolicies),
        lastUpdated: now.toISOString()
      };

      res.json({
        message: 'Compliance status retrieved successfully',
        status: complianceStatus
      });
    } catch (error) {
      logger.error('Error getting compliance status:', error);
      res.status(500).json({ error: 'Failed to get compliance status' });
    }
  }
);

/**
 * Export user data (GDPR compliance)
 * GET /api/compliance/export-user-data/:userId
 */
router.get('/export-user-data/:userId',
  authenticateToken,
  requirePermissions(['admin']),
  auditLog('user_data_export'),
  logSecurityEvent('user_data_exported', 'info', 'User data exported for compliance'),
  async (req, res) => {
    try {
      const { userId } = req.params;

      // Get all user-related data
      const userData = await exportUserData(userId);

      res.json({
        message: 'User data exported successfully',
        data: userData,
        exportedAt: new Date().toISOString(),
        exportedBy: req.user.username
      });

      logger.info(`User data exported for user ID ${userId} by ${req.user.username}`);
    } catch (error) {
      logger.error('Error exporting user data:', error);
      res.status(500).json({ error: 'Failed to export user data' });
    }
  }
);

// Helper functions
function generateCSVReport(data) {
  const auditCSV = [
    'Timestamp,User,Action,Resource Type,Resource ID,IP Address,Details',
    ...data.auditLogs.map(log => 
      `"${log.timestamp}","${log.username || 'System'}","${log.action}","${log.resource_type || ''}","${log.resource_id || ''}","${log.ip_address || ''}","${log.details || ''}"`
    )
  ].join('\n');

  return auditCSV;
}

function generateTradingCSV(data) {
  const tradingCSV = [
    'Timestamp,Bot Name,Symbol,Signal Type,Trading Mode,User,Price,Quantity',
    ...data.tradingSignals.map(signal => 
      `"${signal.timestamp}","${signal.bot_name}","${signal.symbol}","${signal.signal_type}","${signal.trading_mode}","${signal.username}","${signal.price || ''}","${signal.quantity || ''}"`
    )
  ].join('\n');

  return tradingCSV;
}

function calculateComplianceScore(auditLogs, securityEvents, retentionPolicies) {
  let score = 100;
  
  // Deduct points for lack of audit activity
  if (auditLogs === 0) score -= 30;
  
  // Deduct points for critical security events
  const criticalEvents = securityEvents.find(e => e.event_severity === 'critical');
  if (criticalEvents && criticalEvents.count > 0) score -= 20;
  
  // Deduct points for no data retention policies
  if (retentionPolicies.length === 0) score -= 15;
  
  return Math.max(0, score);
}

async function exportUserData(userId) {
  const tables = [
    'users', 'bots', 'trading_signals', 'audit_logs', 
    'api_keys', 'oauth_providers', 'security_events',
    'bot_metrics', 'ml_models', 'ml_predictions'
  ];

  const userData = {};

  for (const table of tables) {
    try {
      const data = await new Promise((resolve, reject) => {
        db.all(
          `SELECT * FROM ${table} WHERE user_id = ?`,
          [userId],
          (err, rows) => {
            if (err) reject(err);
            else resolve(rows);
          }
        );
      });
      userData[table] = data;
    } catch (error) {
      // If table doesn't have user_id column, skip it
      userData[table] = [];
    }
  }

  return userData;
}

module.exports = router;